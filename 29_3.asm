; Program to illustrate the color mapping capabilities of the
; EGA's palette registers.
global start

%include 'common.inc'

BAR_HEIGHT  equ 14
TOP_BAR     equ BAR_HEIGHT * 6

section stack stack
    resb 256

section data
KeyMsg   db 'Press any key to see the next color set. '
         db 'There are 64 color sets in all.'
         db 0dh, 0ah, 0ah, 0ah, 0ah
         times 13 db ' '
         db 'Attribute'
         times 38 db ' '
         db 'Color$'
;
; Used to label the attributes of the color bars.
;
AttributeNumbers:
%assign x 0
%rep 16
  %if x < 10
     db '0', x+'0',   'h';, 0ah, 8, 8, 8
  %else
     db '0', x+'A'-10,'h';, 0ah, 8, 8, 8
  %endif
  db 0ah, 8, 8, 8
  %assign x x+1
%endrep
     db       '$'

ColorNumbers:
%rep 16
    db '000h', 0dh, 0ah,  8, 8, 8, 8
%endrep
ColorNumbers.EntrySize equ ($-ColorNumbers)/16
    db '$'

CurrentColor resb 1

ColorTable resb 16
ColorTable.Size equ ($-ColorTable)
           db 0
section code
start:
    cld
    mov ax, data
    mov ds, ax
    SET_VIDEO_MODE MODE_V640x350x16

    SHOW_MESSAGE data, KeyMsg

; Put up the color bars, one in each of the 16 possible pixel values
; (which we'll call attributes).
    mov cx, 16
    xor al, al
.BarLoop:
    push ax
    push cx
    call BarUp
    pop cx
    pop ax
    inc ax          ; next attribute
    loop .BarLoop

    SET_CURSOR_POS 16, (TOP_BAR/14)
    SHOW_MESSAGE data, AttributeNumbers

; Loop through the color set, one new setting per keypress.
    mov byte [CurrentColor], 0
.ColorLoop:
    mov al, [CurrentColor]
    mov bx, ColorTable
    mov cx, ColorTable.Size
.PaletteSetLoop:
    and al, 0111111b    ; take 6 bits only
    mov [bx], al
    inc bx
    inc ax
    loop .PaletteSetLoop
    mov ah, 10h     ;video interrupt palette function
    mov al, 2       ;subfunction to set all 16 palette registers and overscan at once
    mov dx, ColorTable
    push ds
    pop es
    int 10h
; Put up the color numbers, so we can see how attributes map
; to color values, and so we can see how each color # looks
; (at least on this particular screen).
    call ColorNumbersUp
    WAIT_FOR_KEYPRESS
; Advance to the next color set.
    mov al, [CurrentColor]
    inc al
    mov [CurrentColor], al
    cmp al, 64
    jbe .ColorLoop
.exit:
    WAIT_FOR_KEYPRESS
    SET_VIDEO_MODE MODE_T80x50
    EXIT 0

; Puts up a bar consisting of the specified attribute (pixel value),
; at a vertical position corresponding to the attribute.
; Input: AL = attribute
BarUp:
    mov ah, al              ; the macro below destroys al contents
    SET_SC SC_MAP_MASK, ah
    mov al, BAR_HEIGHT
    mul ah                  ; ax = attribute * BAR_HEIGHT
    add ax, TOP_BAR
    mov dx, 640 / 8         ; row size in bytes
    mul dx                  ; dx:ax = (attr * BAR_HEIGHT + TOP_BAR) * ROW_SIZE
    add ax, 20              ; offset in bytes of upper left corner of bar
    mov di, ax              
    mov ax, VGA_VIDEO_SEGMENT
    mov es, ax
    mov dx, BAR_HEIGHT
    mov al, 0ffh
.BarLineLoop:
    mov cx, 40
    rep stosb           ; one scan line
    add di, 640/8 - 40  ; move to the next scanline of the bar
    dec  dx
    jnz .BarLineLoop
    ret

; Converts AL to a hex digit in the range 0-F.
;
BinToHexDigit:
    cmp al,9
    ja  .IsHex
    add al,'0'
    ret
.IsHex:
    add al,'A'-10
    ret

; Displays the color values generated by the color bars given the
; current palette register settings off to the right of the color
; bars.
ColorNumbersUp:
    SET_CURSOR_POS 20+40+1, TOP_BAR/14
    mov al, [CurrentColor]
    mov bx, ColorNumbers+1
    mov cx, 16
.ColorNumberLoop:
    push ax
    and al, 0111111b
    times 4 shr al, 1
    call BinToHexDigit          ; isolate the high nibble
    mov [bx], al
    pop ax
    push ax
    and al, 0fh                 ; isolate the low nibble
    call BinToHexDigit
    mov [bx+1], al
    add bx, ColorNumbers.EntrySize   ; point to the next entry
    pop ax              ; get back the color
    inc ax
    loop .ColorNumberLoop
    SHOW_MESSAGE data, ColorNumbers
    ret